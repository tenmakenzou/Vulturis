package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"testing"

	"github.com/joho/godotenv"
	"github.com/stretchr/testify/require"
	"github.com/xristoskrik/vulturis/internal/database"
)

// Helper function to setup the database
func setupDB(t *testing.T) func() {
	
	//loading environment variables
	godotenv.Load()
	var dbURL string
	//loading the secret key and database url
	platform :=  os.Getenv("PLATFORM")
	if platform == "dev"{
		dbURL = os.Getenv("DB_URL")
	}else{
		dbURL = os.Getenv("TEST_DB_URL")
	}
	
	//open postgres db
	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		fmt.Println(err)
		t.Fatalf("failed to cleanup users table: %v", err)
	}

	defer db.Close()


	if err != nil {
		t.Fatalf("failed to get db connection: %v", err)
	}

	// Drop all users from the users table
	_, err = db.Exec("DELETE FROM users")
	if err != nil {
		t.Fatalf("failed to clear users table: %v", err)
	}

	// Return a cleanup function to undo changes after test
	return func() {
		_, err := db.Exec("DELETE FROM users") // Cleanup
		if err != nil {
			t.Fatalf("failed to cleanup users table: %v", err)
		}
	}
}
func TestUserCreateHandler(t *testing.T) {
	setupDB(t)
	url := "http://localhost:8080/api/users"
	user := database.User{
		Email:          "testing@email.com",
		HashedPassword:       "12345678", // If you need to handle hashing, adjust this accordingly.
		Phone:          "699999999",
		Mobile:         "99999999",
		Name:           "doe",
		Surname:        "joe",
		Address:        "address 6",
	}
	
	// Marshal the user data to JSON
	jsonData, err := json.Marshal(user)
	if err != nil {
		t.Errorf("failed to Marshal user: %v", err)
	}

	// Create the request
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		t.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Send the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("request failed: %v", err)
	}
	defer resp.Body.Close()

	// Assert the status code is 201 Created
	if resp.StatusCode != http.StatusCreated {
		t.Fatalf("unexpected status code: got %v, want %v", resp.StatusCode, http.StatusCreated)
	}

	// Decode the response body into the expected user structure
	var createdUser database.User
	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&createdUser)
	if err != nil {
		t.Errorf("failed to decode response: %v", err)
	}

	// Assert the fields match the expected user data
	require.Equal(t, user.Email, createdUser.Email)
	require.Equal(t, user.Name, createdUser.Name)
	require.Equal(t, user.Surname, createdUser.Surname)
	require.Equal(t, user.Phone, createdUser.Phone)
	require.Equal(t, user.Mobile, createdUser.Mobile)
	require.Equal(t, user.Address, createdUser.Address)

	// Optionally, check the ID and timestamps (they should be generated by the database)
	require.NotNil(t, createdUser.ID)
	require.NotNil(t, createdUser.CreatedAt)
	require.NotNil(t, createdUser.UpdatedAt)
}

func TestUserDeleteHandler(t *testing.T) {
	// Assuming the user is already created and exists in the database
	// We are just testing the deletion by email.
	emailToDelete := "testing@email.com" // Email of the user to delete

	// Marshal the email into JSON
	requestBody := map[string]string{"email": emailToDelete}
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		t.Errorf("failed to Marshal email: %v", err)
	}

	// Prepare the DELETE request with the JSON body
	deleteURL := "http://localhost:8080/api/users"
	req, err := http.NewRequest("DELETE", deleteURL, bytes.NewBuffer(jsonData))
	if err != nil {
		t.Errorf("failed to create DELETE request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Send the DELETE request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("request failed: %v", err)
	}
	defer resp.Body.Close()

	// Assert that the status code is 204 No Content
	if resp.StatusCode != http.StatusNoContent {
		t.Fatalf("unexpected status code: got %v, want %v", resp.StatusCode, http.StatusOK)
	}
}

